# mymdb
учебный проект сайта mymdb

## Некоторые заметки о разных фичах по ходу кода

### Контроллеры

Разберем, как работает форма для голосования за фильм.

Форма для голосования расположена на одной странице с информацией о фильме (шаблон `movie_detail.html`).

Пользователь попадает на эту страницу через единственный контроллер  `MovieDetail` (наследует от `DetailView`).

Если пользователь не авторизован, всё просто - форма для голосования просто не возникает (в шаблоне предусмотрена переменная контекста `vote_form`, она туда просто не передаётся контроллером).

Если пользователь авторизован, на полную мощь включается переопределение метода `DetailView` под названием `get_context_data`.

Главная проблема: наличие двух возможных сценарий. Первый - пользователь голосует впервые. Второй - пользователь уже голосовал и хочет обновить свой голос.

Шаг 1. Проверяем по базе, голосовал ли пользователь.
```python
            vote = Vote.objects.get_vote_or_unsaved_blank_vote(
                movie=self.object,
                user = self.request.user
            )
```
`get_vote_or_unsaved_blank_vote` - это созданная нами функция внутри кастомного менеджера модели Vote.

```python
class VoteManager(models.Manager):
    def get_vote_or_unsaved_blank_vote(self, movie, user):
        try:
            return Vote.objects.get(movie=movie, user=user, )
        except Vote.DoesNotExist:
            return Vote()
```
В результате к переменной `vote` мы привязываем либо запись о голосе пользователя, либо пустую (и еще не сохраненную в базу) запись.

Шаг 2. По результатам проверки решаем, какой контроллер будет задействован через форму для голосования: контроллер на создание записи впервые проголосовавшего или контроллер на обновление записи уже проголосовавшего.

Решение принимается по результатам проверки `if vote.id`. Айдишник может быть только у существующего голоса.

Шаг 3. Если пользователь ранее уже голосовал, то в переменную `vote_form_url` передается эндпоинт для обновления записи о голосовании (контроллер `UpdateView`).

Если пользователь еще не голосовал, то в переменную `vote_form_url` передаётся эндпоинт для создания новой записи (контроллер `CreateView`).

Шаг 4. В переменную vote_form передается форма с данными о голосе

`vote_form = VoteForm(instance=vote)`

Соответственно, если vote - пустой, то и форма выведется пустая (пользователь еще не голосовал), если же vote содержит существующую запись о голосе, то в форма предстанет перед пользователем заполненной.

Шаг 5. `get_context_data` возвращает дефолтный контекст + две новых переменных: `vote_form` и `vote_form_url`.

В шаблоне они используются следующим образом:
```html
      <form method="post" action="{{ vote_form_url }}"> 
        {% csrf_token %}
        {{ vote_form.as_p }}
        <button class="btn btn-primary">
          Голосовать
        </button >
      </form >
```

### Работа с моделями

```python
    def all_with_related_persons(self):
        qs = self.get_queryset()
        qs = qs.select_related('director') # связь один-ко-многим 
        qs = qs.prefetch_related('writers', 'actors') # связь многие-ко-многим
        return qs
```

Что здесь происходит?
Есть набор записей модели “Фильмы”.
У каждого фильма есть актеры, информация о них в модели “Люди”.

Связь “многие-ко-многим”:
+ Несколько актеров могут сняться в одном и том же фильме
+ Один и тот же актер может сняться в нескольких фильмах

Та же самая история со сценаристами:
+ Несколько сценаристов могут написать сценарий для одного и того же фильма
+ Один и тот же сценарист может написать сценарий для нескольких фильмов

У директора картины связь “один-ко-многим”:
+ Один и тот же директор может руководить несколькими картинами
+ У одной и той же картины может быть только один директор

Поэтому вместо дорогостоящего по запросам менеджера objects, кастомный менеджер делает следующее:
+ берет набор записей и сначала делает запрос select_related для соответствующего поля
+ затем набор записей, уже отобранных по seletc_related, прогоняется через prefetch_related для соответствующих полей.

Таким образом, это хороший пример оптимизации запросов в модели, где есть поля с разными типами связей.

```python
def all_with_related_persons_and_score(self):
        qs = self.all_with_related_persons()
        qs = qs.annotate(score=Sum('vote__value'))
        return qs
```
Обратим внимание на строку `qs.annotate(score=Sum('vote__value'))`

Что делает annotate?

Annotate вычисляет данные для каждой записи в кверисете.
https://djbook.ru/rel1.9/topics/db/aggregation.html#generating-aggregates-for-each-item-in-a-queryset

`annotate()` для каждого объекта QuerySet добавит вычисленное значение.

Особенность приведенного выше примера в том, что в модели `movie` нет поля `vote`.

`vote` - это название модели, которая через fk связана с моделью movie.

Через двойное подчеркивание мы достаём из этой модели значение атрибута `value`. И вот эти `value` мы и суммируем.

Рассмотренный пример - это пример *агрегации по обратным связям*.

https://djbook.ru/rel1.9/topics/db/aggregation.html#following-relationships-backwards 

